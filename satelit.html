<!DOCTYPE html>
<html lang="ca">
  <head>
    <title>Satèl·lit</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background-color: #000;
        margin: 0 0 0 0;
        padding: 0 0 0 0;
        border: none;
        cursor: default;
        overflow: hidden;
      }
      #container {
        height: 100%;
        width: 100%;
        display: flex;
      }
      #dat {
        user-select: none; 
        position: absolute; 
        left: 0;	
        top: 0;	
        z-Index: 200;
      }
      .modal-dialog{
           background-color: white;
           width: 75% !important;
      }
      .modal-header{
           background-color: rgb(224, 236, 247);
      }
      .modal-footer{
          clear:both;
      }			
      .dg .c {
        width: 45% !important;
      }
      .dg .c div {
        box-sizing: content-box;                                                             
      }
      .dg .c select {
        color: black;
        font-size:small;
        width: 190% !important;
        margin-left: -90px;
      }
      .dg .c input[type=text] {                                                    
        line-height:normal;                                                                  
      } 
      .dg .c .slider {
        width: 50%;
      }
      .dg li.title {
        color:rgb(175,0,0);
        font-size:small;
      }
      .dg .property-name {
        font-size:small;
        width: 55% !important;
      }
      .dg .cr.boolean .property-name {
        font-size:small;
      }
      .dg .cr.function .property-name {
        background-color: green;
        text-align: center;
        width: 100% !important;
        font-size:medium;
      }
      .dg .cr.number input[type=text] {
        width: 45%;
      }
      #carregant {
        position: absolute;
        display: unset;
        margin: auto;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        border: 3vmin solid white;
        border-radius: 50%;
        border-top: 3vmin solid blue;
        width: 20vmin;
        height: 20vmin;
        animation: spin 1s linear infinite;
        animation-play-state: running;
      } 
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

    </style>
  </head>
  <body>		
    <div id="container">
      <div id="dat"></div>	
    </div>

    <div id="finestraInfo" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" width='90%' style="visibility: hidden">
      <div class="modal-dialog">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>
          <h3 id="modalHeader"></h3>
        </div>
        <div class="modal-body" id="missatge">
        </div>
        <div class="modal-footer">
          <button class="btn" data-dismiss="modal" aria-hidden="true">Tancar</button>
        </div>
      </div>
    </div> 

    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>     

    <!-- Bootstrap -->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../three.js/build/three.min.js"></script>
    <script src="../three.js/examples/js/renderers/Projector.js"></script>
    <script src="../three.js/examples/js/renderers/CanvasRenderer.js"></script>
    <script src="../three.js/examples/js/libs/dat.gui.min.js"></script>
    <script src="../three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="../three.js/examples/js/loaders/OBJLoader.js"></script>
    <script src="../three.js/examples/js/Detector.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.0.0/satellite.min.js"></script>


    <script>
      var container, camera, camera2D, scene, scene2D, renderer;
      var meshTerra, sat2D, sat3D, trajectoria, llegenda, discs, bateria, orbita, tauler, mapa2D, oceans;
      var omegaSat, periodeSat, aOrbita, bOrbita, eOrbita, pOrbita;
      var angleEscombrat;
      var vEsferic;
      var geometrySat, geometryTrajectoria, materialTrajectoria, geometryLink2D, materialLink2D, geometryLink3D, materialLink3D, geometryDiscs, materialDiscs, geometryBateria, materialBateria, materialOrbita, geometryEstacio, materialEstacio, geometryEstacio3D, materialEstacio3D;
      var textPeriode;
      var grupMon, grupSat;
      var arrowHelper, axesHelper, plaEquatorial, plaOrbita;
      var folder1,folder4;
      var quaternionTerra;
      var estacio=[];
      var estacio3D=[];
      var link2D=[];
      var link3D=[];
      var posLink2D=[];
      var posLink3D=[];
      var proximitat=[];
      var numMoveEstacio;
      var gui;
      var arraySats;
      var nomSatelit=[];
      var numSat=0;
      var noms;
      var satTLEx,satTLEy,satTLEz;
      var mode = 'TLE';
      var angleRotTerra = 0;

      // CONSTANTS TERRA            
      const MU=398694790080000; // G * massa de la Terra, S.I.
      const rTerra=6458428; // radi de l'esfera terrestre, metres
      const segonsDia=23*3600+56*60+4; // nombre de segons que té un dia
      const omega=2*Math.PI/segonsDia; // freqüencia angular de rotació de la Terra entorn al seu eix, rad/s
      const angleTerra= 0 //23.4369*Math.PI/180; // angle d'inclinació de l'eix terrestre, rad
      const omegaSol=omega/365.256363; // freqüencia angular de rotació de la Terra entorn al seu eix, rad/s

      // CONSTANTS SIMULACIÓ
      const maxPoints = 4096; // màxim de punts en la trajectòria
      const maxPointsGraph = 2048; // màxim de punts en les gràfiques
      const shiftCount=1;	// al cap de quants renderings s'agafa un punt de la trajectòria
      const midaSatelit=0.04; // escala d'ampliació del OBJ del satèl·lit
      const centreX=0; // origen en X del mapa 2D de la Terra
      const centreY=0; // origen en Y del mapa 2D de la Terra
      const marge2D=0.1; // marge horitzontal i vertical entre els límits del tauler de gràfiques i els eixos XY
      const mAmplada=1.5; // amplada del mapa 2D de la Terra
      const mAlsada=mAmplada/2; // alçada del mapa 2D de la Terra
      const origenX=centreX - mAmplada + marge2D; // coordenada X de l'origen de coordenades al tauler de gràfiques
      const origenY=centreY + mAlsada + 0.1 + marge2D; // coordenada Y de l'origen de coordenades al tauler de gràfiques
      const finalX=centreX + mAmplada - marge2D; // coordenada X máxima en el tauler de gràfiques
      const finalY=centreY +  4 * mAlsada + 0.1 - marge2D; // coordenada Y máxima en el tauler de gràfiques
      const shiftZ=0.01; // distància entre objectes en la coordenada Z en l'escena 2D.
      const stepAngle=1; // al cap de quants graus es considera un nou punt en la zona de proximitat
      const perCent2D=0.3;

      // CONSTANTS DESPESA DISC I BATERIA
      const ritmeDiscCamera=-0.002;
      const ritmeDiscRadar=-0.002;
      const ritmeDiscTransfer=0.01;
      const ritmeBateriaCamera=-0.001;
      const ritmeBateriaRadar=-0.002;
      const ritmeBateriaDiscs=-0.0001;
      const ritmeBateriaTransfer=-0.005;
      const ritmeBateriaPanell=0.002;

            // VARIABLES DE SIMULACIÓ	
      var ambWebgl;			
      var temps, previousTime, interval; // en segons
      var count; // comptador de punts en la trajectòria
      var countGraph; // comptador de punts en les gràfiques
      var steps; // comptador de renderings
      var enPausa = true; // animació
      var dintre = []; // dins de la zona de proximitat
      var ambLlum = true; // fora de la zona d'ombra
      var maxCountGraph; // nombre de punts necessaris en les gràfiques per representar un dia sencer
      var diaSencer; // ha transcorregut més d'un dia sencer (boolean)
      var nivellDiscs; // espai d'emmagatzematge de dades sense ocupar (%)
      var nivellBateria; // nivell de càrrega de les bateries (%)
      var vectorLlum; // vector amb origen al Sol i final a la Terra (unitari)
      var longitudAnterior; // en el traçat de la trajectòria, longitud del satèl·lit 2D en l'anterior rendering
      var dragging=false; // arrossegant una estació de seguiment
      var angleLatEstacio=[];
      var angleLonEstacio=[];
      angleLatEstacio[0]=41*Math.PI/180;
      angleLonEstacio[0]=2*Math.PI/180;
      var numEstacions=1;
      var satMin=1;
      var botoIniciar;
      var estil;
      var categories;
      var urls;

      // SENSORS
      var row_sen=[];
      var potSensors=0;
      var disSensors=0;

      init();	

      function initGUI() {
        var menuDiv = document.getElementById( 'dat' );
        gui = new dat.GUI({autoPlace: false, width:250});
        menuDiv.appendChild( gui.domElement );
        guiDret = new dat.GUI({width:250});

        folder0 = guiDret.addFolder( 'SATÈL·LIT' );
        folder1 = gui.addFolder( 'ÒRBITA DEL SATÈL·LIT' );
        folder1.add( parametres, "infoParametres").name("Elements orbitals");
        folder1.add( parametres, "longitud", 0, 360, 0.01 ).name("L. node ascendent").onChange(canviaParametres);
        folder1.add( parametres, "inclinacio", 0, 180, 0.01 ).name("Inclinació").onChange(canviaParametres);
        folder1.add( parametres, "argPerigeu", 0, 360, 0.01 ).name("Arg. del perigeu").onChange( canviaParametres);
        folder1.add( parametres, "aOrbita", satMin*rTerra/1000, 50000, 1 ).name("Semieix major").onChange(canviaSemieix);
        folder1.add( parametres, "excentricitat", 0, 1-satMin*rTerra/parametres.aOrbita/1000, 0.00001).name("Excentricitat").onChange(canviaExcentricitat);
        folder1.add( parametres, "anomalia", 0, 360, 0.01 ).name("Anomalia veritable").onChange(canviaParametres);
        
        textPeriode=folder1.add( parametres, "display").name("PERÍODE");
        textPeriode.domElement.childNodes[0].setAttribute("disabled", "true");	
        folder1.add( parametres, "ERA", 0, 360, 0.01).name("Angle rotació Terra").onChange(canviaParametres);
        folder1.open();

        var folder3 = guiDret.addFolder( 'SIMULACIÓ' );				
        //folder3.add( parametres, "mapa", [ 'mapa_simple.png','mapa_fisic.png', 'mapa_politic.png','mapa_gel.png']).name("Tipus de mapa").onChange( canviaMapa );
        botoIniciar = folder3.add( parametres, "pausa").name("I N I C I A");
        estil = botoIniciar.domElement.previousSibling.style;
        folder3.add( parametres, "velAnimacio",1,10,1).name("Velocitat d'animació").onChange( canviaParametres );
        folder3.add( parametres, "veureEixos").name("Mostra eixos i plans").onChange( veureEixos );
        folder3.add( parametres, "veureLine").name("Mostra trajectòria").onChange( veureLine );
        folder3.open();

        addCategories();				
        canviaCategoria();		
      }
      
      function init() {
        // PARÀMETRES DE SIMULACIÓ
        parametres = {
          nomSats : 'Carregant ...',
          longitud: 0, // de l'òrbita del satèl·lit, graus
          inclinacio: 0, // de l'òrbita del satèl·lit, graus
          argPerigeu: 0,
          aOrbita: 20000, // semieix major de l'òrbita el·líptica, km
          excentricitat: 0, // excentricitat de l'òrbita (entre 0 i 1)
          anomalia:0, //
          ERA:0,
          radiProximitat: 4000, // radi de la zona de proximitat a l'estació, km
          afegirEstacio: botoAfegirEstacio,
          eliminarEstacio: botoEliminarEstacio,
          mapa: 'graella.jpg', // fitxer de textura del mapa
          tipus: 'NewSpace Catalunya',
          veureLine: true, // veure o no la trajectòria
          veureEixos: true, // veure o no els eixos i plans
          velAnimacio: 3, // velocitat de l'animació
          display : "", // visualitzador del període del satèl·lit. El valor booleà no té cap efecte
          pausa: botoPausa, // botó per pausar o reprendre la simulació
          //infoSatelit: botoInfoSatelit, // finestra modal amb el satèl·lit 3D
          //infoSensors: botoInfoSensors, // finestra modal amb informació sobre els sensors
          infoParametres: botoInfoParametres, //Presenta la inforació dels paràmetres configurables del simulador
          panells: 1, 
          discs:1,
          cameres: 1,
          radars: 1
        };

        container = document.getElementById( 'container' );
        // CÀMERA
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.up.set(0,0,1);
        camera.position.x = 8; // red
        camera.position.y = -8; // green
        camera.position.z = 1; // blue

        camera2D = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 4, 5);
        camera2D.position.z = 4.5; 

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x131313);

        scene2D = new THREE.Scene();

        // LLUM
        var ambientLight = new THREE.AmbientLight( 0xfffffff ); 
        scene.add(ambientLight);

        var directionalLight = new THREE.DirectionalLight( 0xffffff, 1);

        vectorLlum=new THREE.Vector3(0,-1,0);
        directionalLight.position.set(-vectorLlum.x, -vectorLlum.y, -vectorLlum.z);
        directionalLight.castShadow=true;
        scene.add( directionalLight );     

        grupMon=new THREE.Group();

        // EIXOS DE COORDENADES
        axesHelper = new THREE.AxesHelper(1.1);
        scene.add( axesHelper );

        // EIX TERRA
        var dir = new THREE.Vector3(0,Math.sin(angleTerra),Math.cos(angleTerra));
        var origin = new THREE.Vector3( 0, 0, 0 );
        arrowHelper = new THREE.ArrowHelper( dir, origin, 1.1, 0x555555, 0.075, 0.05);
        scene.add( arrowHelper );

        // TERRA I MAPA 2D
        canviaMapa();

        // SATÈL·LIT 3D
        var manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {
          grupSat=new THREE.Group();
          grupSat.add(sat3D);	
          grupMon.add(grupSat);
          canviaParametres();
          animate();
        };
        var onProgress = function ( xhr ) {
          if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
          }
        };
        var onError = function ( xhr ) {
        };
        var loader = new THREE.OBJLoader( manager );
        loader.load( 'imatges/sat3.obj', function ( object ) {
          object.traverse( function ( child ) {
            if ( child instanceof THREE.Mesh ) {
              child.material=new THREE.MeshStandardMaterial( { color: 0x565758, overdraw: true} );
                            child.receiveShadow = true;
            }
          } );
          object.scale.set(midaSatelit,midaSatelit,midaSatelit);
          sat3D=object.clone();					
        }, onProgress, onError );				

        // SATÈL·LIT 2D
        materialSat2D = new THREE.MeshBasicMaterial( { color: 0xffffff} );
        var geometrySat2D = new THREE.CircleGeometry(0.02);
        sat2D= new THREE.Mesh( geometrySat2D, materialSat2D );
        scene2D.add(sat2D);
        
        // MÀSCARA OCEANS
        var managerOceans = new THREE.LoadingManager();
        managerOceans.onProgress = function ( item, loaded, total ) {
        //scene2D.add(oceans);
        };
        var loader = new THREE.OBJLoader( managerOceans );
        loader.load( 'imatges/oceans.obj', function ( object ) {
          object.scale.set(0.0118,0.0118,0.0118);
          object.position.set(centreX,centreY,-shiftZ);
          oceans=object.clone();					
        }, onProgress, onError );

        // ÒRBITA
        materialOrbita = new THREE.LineBasicMaterial( { color : 0xffffff, linewidth: 2 } );
        var geometryOrbita = new THREE.BufferGeometry();
        orbita = new THREE.Line( geometryOrbita, materialOrbita );

        // PLA EQUATORIAL
        materialPlaEquatorial = new THREE.MeshPhongMaterial({color: 0xffff00, opacity: 0.5,transparent: true, side: THREE.DoubleSide});
        var geometryPlaEquatorial = new THREE.PlaneGeometry( 8, 8 );
        plaEquatorial = new THREE.Mesh( geometryPlaEquatorial, materialPlaEquatorial );
        scene.add(plaEquatorial);

        // PLA ÒRBITA
        materialPlaOrbita = new THREE.MeshPhongMaterial({color: 0xff0000, opacity: 0.5,transparent: true, side: THREE.DoubleSide});
        var geometryPlaOrbita = new THREE.PlaneGeometry( 8, 8 );
        plaOrbita = new THREE.Mesh( geometryPlaOrbita, materialPlaOrbita );

        // EIXOS 2D
        var geometryEixos = new THREE.Geometry();
        materialEixos = new THREE.LineBasicMaterial( { color : 0x000000,linewidth: 2 } );
        geometryEixos.vertices.push(new THREE.Vector3( finalX, origenY, 3*shiftZ) );
        geometryEixos.vertices.push(new THREE.Vector3( origenX, origenY , 3*shiftZ) );
        geometryEixos.vertices.push(new THREE.Vector3( origenX, finalY, 3*shiftZ) );
        var eixos2D = new THREE.Line( geometryEixos, materialEixos );
        //scene2D.add(eixos2D);

        // TRAJECTÒRIA
        materialTrajectoria = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });

        // LINK 2D
        materialLink2D = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });
        geometryLink2D = new THREE.BufferGeometry();
        link2D[0] = new THREE.Line(geometryLink2D, materialLink2D);

        // LINK 3D
        materialLink3D = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });

        // DISCS
        materialDiscs = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2	});

        // BATERIA
        materialBateria = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2	});

        // ESTACIÓ 2D
        materialEstacio = new THREE.MeshBasicMaterial( { color: 0xff0000} );
        geometryEstacio = new THREE.CircleGeometry(0.03);
        estacio[0]= new THREE.Mesh( geometryEstacio, materialEstacio );
        //scene2D.add(estacio[0]);

        // ESTACIÓ 3D
        materialEstacio3D = new THREE.MeshBasicMaterial( { color: 0xff0000} );
        geometryEstacio3D = new THREE.SphereGeometry( 0.02, 6, 6 );
        estacio3D[0] = new THREE.Mesh( geometryEstacio3D, materialEstacio3D );
        mouEstacio(0);				

        // TAULER DE GRÀFIQUES				

        var geometryTauler = new THREE.PlaneGeometry(2*mAmplada, 3*mAlsada );
        var materialTauler = new THREE.MeshBasicMaterial(  { color: 0xffffff, overdraw: true } );
        tauler = new THREE.Mesh( geometryTauler, materialTauler );
        tauler.position.x=centreX;
        tauler.position.y=centreY+2.5*mAlsada+0.1;
        tauler.position.z=2*shiftZ;
        //scene2D.add( tauler );

        var loader = new THREE.TextureLoader();
        loader.load( 'imatges/'+"llegenda.png", function ( texture ) {
          var geometryLlegenda = new THREE.PlaneGeometry(203/200,46/200);
          var materialLlegenda = new THREE.MeshBasicMaterial( {map: texture} );
          llegenda = new THREE.Mesh( geometryLlegenda, materialLlegenda);
          llegenda.position.x=0.9;
          llegenda.position.y=centreY+1.1;
          llegenda.position.z=3*shiftZ;
          //scene2D.add( llegenda );
        } );

        // MÓN
        grupMon.setRotationFromAxisAngle(new THREE.Vector3(1,0,0),-angleTerra);
        scene.add(grupMon);
      
        // RENDERER
        if (Detector.webgl) {
          ambWebgl=true;
          renderer = new THREE.WebGLRenderer();
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        } else {
          ambWebgl=false;
          renderer = new THREE.CanvasRenderer();
          console.log("WebGL no és compatible, renderitzant amb CanvasRenderer.");
          alert("Aquest navegador no és compatible amb WebGL,\nalgunes funcionalitats del simulador no estaran disponibles.");
        }
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;
        container.appendChild( renderer.domElement );
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'mousedown', onMouseDown, false );
        window.addEventListener( 'mouseup', onMouseUp, false );
        window.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'focus', onFocus, false );
        //window.addEventListener( 'touchstart', onTouchStart, false );
        //window.addEventListener( 'touchmove', onTouchMove, false );
        //window.addEventListener( 'touchend', onTouchEnd, false );

        initGUI();
      }

      function onFocus(){
        canviaParametres();
      }

      /*function onTouchStart(evt){
        evt.preventDefault();
        evt.stopPropagation();
        var touches = evt.changedTouches;
        getLatLon(parseInt(touches[0].clientX),parseInt(touches[0].clientY));
        numMoveEstacio=-1;			
        var i=0;
        do {					
          intersects=rayCaster.intersectObject(estacio[i],true);				
          if (intersects.length > 0) {
            alert(parseInt(touches[0].clientX));
            numMoveEstacio=i;
            controls.enabled=false;
            dragging=true;
            scene2D.remove(proximitat[numMoveEstacio]);
          }
          i++;
        }
        while(numMoveEstacio<0 && i<numEstacions);
      }*/

      function getLatLon(X,Y) {
        mousePosition = new THREE.Vector2();
        canvas = renderer.domElement;
        canvasPosition = $(canvas).position();
        rayCaster = new THREE.Raycaster();
        var left=(1-perCent2D)*window.innerWidth+1;
        var width=perCent2D*window.innerWidth-2;

        mousePosition.x = ((X - left) / width) * 2 - 1;
        mousePosition.y = -((Y - canvasPosition.top) / canvas.height) * 2 + 1;

        rayCaster.setFromCamera(mousePosition, camera2D);
      }

      function onMouseDown(evt) {
        
        getLatLon(evt.clientX,evt.clientY);
        numMoveEstacio=-1;			
        var i=0;
        do {					
          intersects=rayCaster.intersectObject(estacio[i],true);				
          if (intersects.length > 0) {
            evt.preventDefault();
            numMoveEstacio=i;
            controls.enabled=false;
            dragging=true;
            scene2D.remove(proximitat[numMoveEstacio]);
          }
          i++;
        }
        while(numMoveEstacio<0 && i<numEstacions);			
      };

      function onMouseMove(evt) {
        if (dragging) {
          evt.preventDefault();
          getLatLon(evt.clientX,evt.clientY);
          intersects = rayCaster.intersectObject(mapa2D, true);
          if (intersects.length > 0) {
            estacio[numMoveEstacio].position.x=intersects[0].point.x;
            estacio[numMoveEstacio].position.y=intersects[0].point.y;
          }
        }
      }

      function onMouseUp(evt) {
        if (dragging) {
          evt.preventDefault();
          getLatLon(evt.clientX,evt.clientY);
          intersects = rayCaster.intersectObject(oceans, true);
          if (intersects.length > 0) {
            alert("L'estació de seguiment ha d'estar en terra ferma,\nno pot ubicar-se a l'oceà.")
          } else {
            angleLatEstacio[numMoveEstacio]=(estacio[numMoveEstacio].position.y-centreY)*Math.PI/mAmplada;
            angleLonEstacio[numMoveEstacio]=(estacio[numMoveEstacio].position.x-centreX)*Math.PI/mAmplada;
          }
          mouEstacio(numMoveEstacio);
          controls.reset();
          controls.enabled=true;					
          dragging=false;
        }
      }

      function botoPausa() {		
        enPausa=!enPausa;
        if (!enPausa) {
          estil.backgroundColor = 'IndianRed';
          botoIniciar.name("P A U S A");
          previousTime=new Date().getTime();
          animate();
        } else {
          estil.backgroundColor = 'green';
          botoIniciar.name("C O N T I N U A");
        }
      }

      function addGraph() {
        if(!enPausa) {
          if (temps>segonsDia) {
            if(!diaSencer) {
              finalCountGraph=countGraph;
              diaSencer=true;
            }
          }

          ritmeDisc=parametres.cameres*ritmeDiscCamera;
          ritmeDisc+=parametres.radars*ritmeDiscRadar;
          for(i=0;i<numEstacions;i++) {
            if (dintre[i]) {
              ritmeDisc+=ritmeDiscTransfer;
            }
          }
          nivellDiscs+=parametres.velAnimacio*interval*shiftCount*ritmeDisc/parametres.discs;
          if (nivellDiscs>100) {
            nivellDiscs=100;
          }
          if (nivellDiscs<0) {
            nivellDiscs=0;
          }

          var ritmeBateria=parametres.cameres*ritmeBateriaCamera;
          ritmeBateria+=parametres.radars*ritmeBateriaRadar;
          ritmeBateria+=parametres.discs*ritmeBateriaDiscs;
          if (ambLlum) {
            ritmeBateria=parametres.panells*ritmeBateriaPanell
          }
          nivellBateria+=parametres.velAnimacio*interval*shiftCount*ritmeBateria;
          if (nivellBateria>100) {
            nivellBateria=100;
          }
          if (nivellBateria<0) {
              nivellBateria=0;
          }
          
          if (diaSencer) {
            posDiscs[finalCountGraph * 3 + 0] = finalX;
            posDiscs[finalCountGraph * 3 + 1] = origenY+(finalY-origenY)/100*(100-nivellDiscs);
            posDiscs[finalCountGraph * 3 + 2] = 3*shiftZ;	
            posBateria[finalCountGraph * 3 + 0] = finalX;
            posBateria[finalCountGraph * 3 + 1] = origenY+(finalY-origenY)/100*nivellBateria;
            posBateria[finalCountGraph * 3 + 2] = 3*shiftZ;	
            for(i=0;i<finalCountGraph;i++){							
              posDiscs[i* 3 + 1] = posDiscs[i* 3 + 4];
              posBateria[i* 3 + 1] = posBateria[i* 3 + 4];
            }
          } else {
            posDiscs[countGraph * 3 + 0] = origenX+temps*(finalX-origenX)/segonsDia;
            posDiscs[countGraph * 3 + 1] = origenY+(finalY-origenY)/100*(100-nivellDiscs);
            posDiscs[countGraph * 3 + 2] = 3*shiftZ;
            posBateria[countGraph * 3 + 0] = origenX+temps*(finalX-origenX)/segonsDia;
            posBateria[countGraph * 3 + 1] = origenY+(finalY-origenY)/100*nivellBateria;
            posBateria[countGraph * 3 + 2] = 3*shiftZ;
            for(i=countGraph+1;i<maxPointsGraph;i++){							
              posDiscs[i* 3 + 2] = -100;
              posBateria[i* 3 + 2] = -100;
            }
            countGraph++;
          }
        
          discs.geometry.attributes.position.needsUpdate = true;
          bateria.geometry.attributes.position.needsUpdate = true;
        }								
      }

      function addPoint(){
        if(!enPausa) {
          pos2D[count * 3 + 0] = sat2D.position.x;
          pos2D[count * 3 + 1] = sat2D.position.y;
          pos2D[count * 3 + 2] = sat2D.position.z;	

          if(count==maxPoints-1) {
            for(i=0;i<maxPoints*3-3;i++) {
              pos2D[i]=pos2D[i+3];
            }
          }
          else {
            for(i=count+1;i<maxPoints;i++){							
              pos2D[i* 3 + 2] = -100;
            }
            count++;
          }		

          trajectoria.geometry.attributes.position.needsUpdate = true;
          
          var laLatitud=(sat2D.position.y-centreY)*Math.PI/mAmplada;
          var laLongitud=(sat2D.position.x-centreX)*Math.PI/mAmplada;

          for(i=0;i<numEstacions;i++) {
            var distanciaActual=distancia(angleLatEstacio[i],laLatitud,angleLonEstacio[i],laLongitud);
            if (distanciaActual<parametres.radiProximitat*1000) {
              dintre[i]=true;
            }
            else {
              dintre[i]=false;
            }
          }

          var vectorSat3D=new THREE.Vector3();
          sat3D.getWorldPosition(vectorSat3D);
          var vectorSatUnitari=new THREE.Vector3().copy(vectorSat3D).multiplyScalar(1/vectorSat3D.length());
          
          ambLlum=true;
          var cosinus=vectorSatUnitari.dot(vectorLlum)
          var radiLlum=vectorSat3D.length()*Math.sin(Math.acos(cosinus));
          if (cosinus>0 && radiLlum<1) {
            ambLlum=false;
          }
          ambLlum=true; //Sempre amb llum
        }
      }

      function addLink() {
        var worldSat3D=new THREE.Vector3();
        sat3D.getWorldPosition(worldSat3D);

        for(i=0;i<numEstacions;i++) {
          if (posLink2D[i]!=null) {
            posLink2D[i][0]=estacio[i].position.x;
            posLink2D[i][1]=estacio[i].position.y;
            posLink2D[i][3]=sat2D.position.x;
            posLink2D[i][4]=sat2D.position.y;

            var worldEstacio3D=new THREE.Vector3();
            estacio3D[i].getWorldPosition(worldEstacio3D);

            if (dintre[i]) {
              posLink2D[i][2]=estacio[i].position.z;
              posLink2D[i][5]=sat2D.position.z;
              posLink3D[i][0]=worldEstacio3D.x;
              posLink3D[i][1]=worldEstacio3D.y;
              posLink3D[i][2]=worldEstacio3D.z;
              posLink3D[i][3]=worldSat3D.x;
              posLink3D[i][4]=worldSat3D.y;
              posLink3D[i][5]=worldSat3D.z;
            }
            else {
              posLink2D[i][2]=0;
              posLink2D[i][5]=0;
              for(j=0;j<6;j++) {
                posLink3D[i][j]=0;
              }
            }
            link2D[i].geometry.attributes.position.needsUpdate = true;
            link3D[i].geometry.attributes.position.needsUpdate = true;
          }
        }
      }

      function veureLine() {
        if(parametres.veureLine) {
          scene2D.add(trajectoria);
        } else {
          scene2D.remove(trajectoria);
        }  
      }

      function veureEixos() {
        if(parametres.veureEixos) {
          scene.add(arrowHelper);
          scene.add(axesHelper);
          scene.add(plaEquatorial);
          grupMon.add(plaOrbita);
        } else {
          scene.remove(arrowHelper);
          scene.remove(axesHelper);
          scene.remove(plaEquatorial);
          grupMon.remove(plaOrbita);
        }  
      }

      function canviaSemieix() {
        var eMax=1-satMin*rTerra/(parametres.aOrbita*1000);
        folder1.__controllers[5].max(eMax);
        canviaParametres();
      }

      function canviaExcentricitat() {
        var aMin=satMin*rTerra/(1-parametres.excentricitat)/1000;
        folder1.__controllers[4].min(aMin);
        canviaParametres();
      }

      function canviaParametres() {
        var angleInclinacio= parametres.inclinacio * Math.PI/180;
        var angleLongitud = (parametres.longitud + 90 ) * Math.PI/180;
        var anglePerigeu = (parametres.argPerigeu -90) * Math.PI/180;

        longitudAnterior=angleLongitud;

        var quaternionPerigeu=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),anglePerigeu);
        var quaternionInclinacio=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -angleInclinacio);
        var quaternionLongitud=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), angleLongitud);
        quaternionTerra=new THREE.Quaternion().multiplyQuaternions(quaternionLongitud,new THREE.Quaternion().multiplyQuaternions(quaternionInclinacio,quaternionPerigeu));

        angleEscombrat=Math.PI/180*(parametres.anomalia);

        eOrbita=parametres.excentricitat;				

        aOrbita=parametres.aOrbita*1000;
        pOrbita=aOrbita*(1-eOrbita);
        bOrbita=aOrbita*Math.sqrt(1-eOrbita*eOrbita);
        periodeSat=2*Math.PI*Math.sqrt(aOrbita**3/MU);
        omegaSat=2*Math.PI/periodeSat;

        var hores=Math.floor(periodeSat/3600);
        var minuts=Math.floor((periodeSat - 3600 * hores)/60);
        var segons=Math.floor(periodeSat-hores*3600-minuts*60 );
        var stringPeriode= hores + "h " + minuts + "' " + segons + "''";
        folder1.__controllers[7].setValue(stringPeriode);

        // SAT 3D
        var mida=0.02*pOrbita/rTerra;
        sat3D.scale.set(mida,mida,mida);			

        // ÒRBITA
        grupMon.remove(orbita);
        var curve = new THREE.EllipseCurve((pOrbita-aOrbita)/rTerra,0,aOrbita/rTerra,bOrbita/rTerra,0,2*Math.PI,false,0);
        var points = curve.getPoints(360);
        var geometryOrbita = new THREE.BufferGeometry().setFromPoints(points);
        orbita = new THREE.Line( geometryOrbita, materialOrbita );
        orbita.quaternion.copy(quaternionTerra);
        grupMon.add(orbita);	
        
        // PLA ORBITA
        if(parametres.veureEixos) {
          grupMon.remove(plaOrbita);
        }
        var quaternionPla=new THREE.Quaternion().multiplyQuaternions(quaternionLongitud,quaternionInclinacio);				
        plaOrbita.quaternion.copy(quaternionPla);
        if(parametres.veureEixos) {
          grupMon.add(plaOrbita);
        }
        
        // TRAJECTÒRIA
        scene2D.remove(trajectoria);
        geometryTrajectoria = new THREE.BufferGeometry();
        pos2D = new Float32Array(maxPoints * 3);
        geometryTrajectoria.addAttribute('position', new THREE.BufferAttribute(pos2D, 3));
        geometryTrajectoria.setDrawRange( 2, maxPoints );
        trajectoria = new THREE.Line(geometryTrajectoria, materialTrajectoria);
        scene2D.add(trajectoria);

        // LINK 2D
        for(i=0;i<numEstacions;i++) {
          scene2D.remove(link2D[i]);
          geometryLink2D = new THREE.BufferGeometry();
          posLink2D[i] = new Float32Array(2 * 3);
          geometryLink2D.addAttribute('position', new THREE.BufferAttribute(posLink2D[i], 3));
          link2D[i] = new THREE.Line(geometryLink2D, materialLink2D);
          if (ambWebgl) {
            //scene2D.add(link2D[i]);
          }
        }

        // LINK 3D
        for(i=0;i<numEstacions;i++) {
          scene.remove(link3D[i]);
          geometryLink3D = new THREE.BufferGeometry();
          posLink3D[i] = new Float32Array(2 * 3);
          geometryLink3D.addAttribute('position', new THREE.BufferAttribute(posLink3D[i], 3));
          link3D[i] = new THREE.Line(geometryLink3D, materialLink3D);
          //scene.add(link3D[i]);
        }

        // UNITATS DE DISC
        scene2D.remove(discs);
        geometryDiscs = new THREE.BufferGeometry();
        posDiscs = new Float32Array(maxPointsGraph * 3);
        geometryDiscs.addAttribute('position', new THREE.BufferAttribute(posDiscs, 3));
        geometryDiscs.setDrawRange( 1, maxPointsGraph );
        discs = new THREE.Line(geometryDiscs, materialDiscs);
        //scene2D.add(discs);

        // BATERIA
        scene2D.remove(bateria);
        geometryBateria = new THREE.BufferGeometry();
        posBateria = new Float32Array(maxPointsGraph * 3);
        geometryBateria.addAttribute('position', new THREE.BufferAttribute(posBateria, 3));
        geometryBateria.setDrawRange( 1, maxPointsGraph );
        bateria = new THREE.Line(geometryBateria, materialBateria);
        //scene2D.add(bateria);
    
        // REININCI SIMULACIÓ

        previousTime=new Date().getTime();
        temps=0;
        diaSencer=false;
        count=0;
        countGraph=0;
        steps=0;
        nivellDiscs=100;
        nivellBateria=50;
        angleEscombrat=Math.PI/180*(parametres.anomalia);
        veureLine();
        
        // POSICIÓ TERRA

        var vectorSat3D = new THREE.Vector3();
        var radi;
        if(mode == 'TLE') {
          var distanciaProva;
          var distanciaSat = (pOrbita/rTerra)**2;
          var graus;
          // Acotar entre 0 i 360 graus i després acotar 2 decimals
          for(i=0;i<360;i++){
            an = i * Math.PI/180;
            radi=pOrbita/rTerra*(1+eOrbita)/(1+eOrbita*Math.cos(an));
            sat3D.position.x=radi*Math.cos(an);
            sat3D.position.y=radi*Math.sin(an);
            sat3D.getWorldPosition(vectorSat3D);
            distanciaProva = (satTLEx-vectorSat3D.x)**2+(satTLEy-vectorSat3D.y)**2+(satTLEz-vectorSat3D.z)**2;
            if(distanciaProva < distanciaSat) {
              distanciaSat = distanciaProva;
              graus = i;
            }
          }
          for(i=0;i<200;i++){
            an = (graus -1 + i/100) * Math.PI/180;
            radi=pOrbita/rTerra*(1+eOrbita)/(1+eOrbita*Math.cos(an));
            sat3D.position.x=radi*Math.cos(an);
            sat3D.position.y=radi*Math.sin(an);
            sat3D.getWorldPosition(vectorSat3D);
            distanciaProva = (satTLEx-vectorSat3D.x)**2+(satTLEy-vectorSat3D.y)**2+(satTLEz-vectorSat3D.z)**2;
            if(distanciaProva < distanciaSat) {
              distanciaSat = distanciaProva;
              angleEscombrat = an;
            }
          }

        } else { // mode manual
          angleRotTerra = - parametres.ERA * Math.PI / 180;
        }
        radi = pOrbita/rTerra*(1+eOrbita)/(1+eOrbita*Math.cos(angleEscombrat));
        sat3D.position.x=radi*Math.cos(angleEscombrat);
        sat3D.position.y=radi*Math.sin(angleEscombrat);

        render();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        camera2D.aspect = window.innerWidth / window.innerHeight;
        camera2D.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        requestAnimationFrame( animate );
        render();
      }
      
      function render() {
        if (!enPausa) {
          var currentTime = new Date().getTime();
          interval= currentTime - previousTime;
          temps+=parametres.velAnimacio* interval;
          previousTime = currentTime;	
        }

        if(meshTerra!=null) {
          var quaternionZ=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), omega*temps - angleRotTerra);
          meshTerra.quaternion.copy(quaternionZ);
        }

        if (!enPausa) {
          angleEscombrat+=Math.sqrt(MU/((aOrbita*(1-eOrbita**2))**3))*(1+eOrbita*Math.cos(angleEscombrat))**2*parametres.velAnimacio*interval;
        }

        var quaternion=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),Math.PI + angleEscombrat);
        sat3D.quaternion.copy(quaternion);
        
        var radi=pOrbita/rTerra*(1+eOrbita)/(1+eOrbita*Math.cos(angleEscombrat));
        sat3D.position.x=radi*Math.cos(angleEscombrat);
        sat3D.position.y=radi*Math.sin(angleEscombrat);

        var vectorSatTerra=new THREE.Vector3(sat3D.position.x,sat3D.position.y,0);
        vectorSatTerra.applyQuaternion(quaternionTerra);
        vEsferic=coordEsferiques(vectorSatTerra);

        grupSat.quaternion.copy(quaternionTerra);		
        


        var voltes=Math.floor((vEsferic.z - omega * temps + angleRotTerra + Math.PI) / (2 * Math.PI));
        var longitudMapa=vEsferic.z -omega * temps + angleRotTerra - voltes * 2 * Math.PI 
        
        if(longitudMapa*longitudAnterior<0 && Math.abs(longitudMapa)>Math.PI/2){
          sat2D.position.z=-100;
          addPoint();
          addGraph();
        }
        longitudAnterior=longitudMapa;	

        sat2D.position.x=centreX+longitudMapa*mAmplada/Math.PI;
        sat2D.position.y=centreY+(Math.PI/2-vEsferic.y)*2*mAlsada/Math.PI;
        sat2D.position.z=shiftZ;	

        steps++;
        if (temps>0) {
          if (steps % shiftCount == 0) {
            addPoint();	
            addLink();
            addGraph();					
          }
        } 

        camera.aspect=(1-perCent2D)*window.innerWidth/window.innerHeight;
        camera2D.aspect=perCent2D*window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        camera2D.updateProjectionMatrix();

        renderer.setViewport(0,0,window.innerWidth,window.innerHeight);
                renderer.clear();	
        renderer.setViewport(1,1,(1-perCent2D)*window.innerWidth-2,window.innerHeight-2);
                renderer.render( scene, camera );
        renderer.setViewport((1-perCent2D)*window.innerWidth+1,1,perCent2D*window.innerWidth-2,window.innerHeight-2);
                renderer.render( scene2D, camera2D );	
      }
    
      function coordEsferiques(vector) {
        var r=vector.length();
        var theta=Math.acos(vector.z/r);
        var phi=Math.atan2(vector.y,vector.x);
        return(new THREE.Vector3(r,theta,phi));
      }

      function canviaMapa() {
        var loader = new THREE.TextureLoader();
        loader.load( 'imatges/'+parametres.mapa, function (texture) {
          // MAPA 2D
          scene2D.remove(mapa2D);
          var geometryMapa2D = new THREE.PlaneGeometry(2*mAmplada, 2*mAlsada );
          var materialMapa2D = new THREE.MeshBasicMaterial(  { map: texture, overdraw: true});
          mapa2D = new THREE.Mesh( geometryMapa2D, materialMapa2D );
          mapa2D.position.x=centreX;
          mapa2D.position.y=centreY;
          mapa2D.position.z=0;
          scene2D.add( mapa2D );
          // TERRA
          grupMon.remove( meshTerra );
          var geometryTerra = new THREE.SphereGeometry( 1, 40, 40 );
          geometryTerra.rotateX(Math.PI/2);
          var materialTerra = new THREE.MeshLambertMaterial({ map: texture, overdraw: true });
          meshTerra = new THREE.Mesh( geometryTerra, materialTerra );
          meshTerra.castShadow=true;
          grupMon.add( meshTerra );
          for(i=0;i<numEstacions;i++) {
          }
        } );	
      }

      function botoEliminarEstacio() {
        numEstacions--;
        scene.remove(estacio3D[numEstacions]);
        scene2D.remove(estacio[numEstacions]);
        scene2D.remove(link2D[numEstacions]);
        scene2D.remove(link3D[numEstacions]);
        scene2D.remove(proximitat[numEstacions]);
      }

      function botoAfegirEstacio() {
        if (numEstacions==1) {
          alert("La nova estació s'ha ubicat provisionalment en el mapa.\nPots canviar la ubicació de les estacions arrossegant-les\namb el ratolí.")
        }
        angleLatEstacio[numEstacions]=10*Math.PI/180;
        angleLonEstacio[numEstacions]=0;

        estacio[numEstacions]= new THREE.Mesh( geometryEstacio, materialEstacio );

        estacio3D[numEstacions]= new THREE.Mesh( geometryEstacio3D, materialEstacio3D );	

        mouEstacio(numEstacions);
        numEstacions++;
      }

      function canviaRadiProximitat() {	
        var distanciaZona=parametres.radiProximitat*1000/rTerra;			
        for(j=0;j<numEstacions;j++) {		
          scene2D.remove(proximitat[j]);
          var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );
          var geometry = new THREE.Geometry();
          for (i=0;i<=360;i+=stepAngle) {
            azimuth=i*Math.PI/180;
            var novCoord=novesCoordenades(angleLatEstacio[j],angleLonEstacio[j],azimuth,distanciaZona)
            var xProximitat=centreX+novCoord.y*mAmplada/Math.PI;
            var yProximitat=centreY+novCoord.x*mAmplada/Math.PI;
            geometry.vertices.push(new THREE.Vector3(xProximitat, yProximitat, shiftZ) );
          }
          proximitat[j] = new THREE.Line( geometry, material );
          //scene2D.add(proximitat[j]);
        }
      }

      function mouEstacio(numEst) {
        estacio[numEst].position.x=centreX+angleLonEstacio[numEst]*mAmplada/Math.PI;
        estacio[numEst].position.y=centreY+angleLatEstacio[numEst]*mAmplada/Math.PI;
        estacio[numEst].position.z=shiftZ;

        estacio3D[numEst].position.x=Math.sin(Math.PI/2-angleLatEstacio[numEst])*Math.cos(angleLonEstacio[numEst]);
        estacio3D[numEst].position.y=Math.sin(Math.PI/2-angleLatEstacio[numEst])*Math.sin(angleLonEstacio[numEst]);
        estacio3D[numEst].position.z=Math.cos(Math.PI/2-angleLatEstacio[numEst]);

        //ZONA DE PROXIMITAT

        scene2D.remove(proximitat[numEst]);
        var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );
        var distanciaZona=parametres.radiProximitat*1000/rTerra;

        var geometry = new THREE.Geometry();
        for (i=0;i<=360;i+=stepAngle) {
          azimuth=i*Math.PI/180;
          var novCoord=novesCoordenades(angleLatEstacio[numEst],angleLonEstacio[numEst],azimuth,distanciaZona)
          var xProximitat=centreX+novCoord.y*mAmplada/Math.PI;
          var yProximitat=centreY+novCoord.x*mAmplada/Math.PI;
          geometry.vertices.push(new THREE.Vector3(xProximitat, yProximitat, shiftZ) );
        }
        proximitat[numEst] = new THREE.Line( geometry, material );
      }

      function distancia(lat1,lat2,lon1,lon2) {			 	
        var dfi = (lat2-lat1);
        var dlambda = (lon2-lon1);
        var a = Math.sin(dfi/2) * Math.sin(dfi/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(dlambda/2) * Math.sin(dlambda/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var d = rTerra * c;
        return d;
      }

      function novesCoordenades(fi1, lambda1, azimuth, distance) {
        var delta = distance;
        var deltafi = delta * Math.cos(azimuth);
        var fi2 = fi1 + deltafi;
        var deltapsi = Math.log(Math.tan(fi2/2+Math.PI/4)/Math.tan(fi1/2+Math.PI/4));
        var q = Math.abs(deltapsi) > 10e-12 ? deltafi / deltapsi : Math.cos(fi1);
        var deltalambda = delta*Math.sin(azimuth)/q;
        var lambda2 = lambda1 + deltalambda;
        if (fi2>Math.PI/2) {fi2=Math.PI/2;}
        if (fi2<-Math.PI/2) {fi2=-Math.PI/2;}
        if (lambda2>Math.PI) {lambda2=Math.PI;}
        if (lambda2<-Math.PI) {lambda2=-Math.PI;}
        return new THREE.Vector3(fi2,lambda2,0);
      }
      
      function botoInfoSensors() {			 	
          $.ajax({
              type: "GET",
              url: "https://docs.google.com/spreadsheets/d/1Ba-fxzhfwNNLMs_uMRLbJCzAuFO2ReOXzoOytcYsUOw/gviz/tq?tqx=out:csv",
              dataType: "text",
              success: function(data) {processData(data);}
           });

        function processData(allText) {
          var csv=allText;
          var msgDiv="<table style='width:100%'>";
          var lines=csv.split("\n");
          row_sen = [];

          for(var i=0; i<lines.length; i++) {
            row_sen[i]=lines[i].split(",");
            msgDiv +="<tr>";
            if (i>0){
              msgDiv +="<td style='border: 1px solid #cacaca; padding:3px;'><input type='checkbox' class='sensor' name='sensor_"+i+"' id='sensor_"+i+"' onchange='calPotencia()'/></td>";		
            } else {
              msgDiv +="<td style='border: 1px solid #cacaca; padding:3px; background-color: #cacaca'>Sel</td>"
            }
            for(var c=0; c<row_sen[i].length-1; c++) {	  		
              var senVal=row_sen[i][c].substring(1,row_sen[i][c].length-1);
              if (c==100){
                msgDiv +="<td style='border: 1px solid #cacaca; padding:3px'>"+senVal+"<br><button data-toggle='collapse' data-target='#demo'>Més informació</button><div id='demo' class='collapse'>Lorem ipsum dolor text....</div></td>";
              } else {
                msgDiv +="<td style='border: 1px solid #cacaca; padding:3px'>"+senVal+"</td>";
              }
            }
            var senVal=row_sen[i][c].substring(1,row_sen[i][c].length-1);  						
            msgDiv +="<td style='border: 1px solid #cacaca; padding:3px'><img src='"+senVal+"' style='width:30%'/></td>";
            msgDiv +="<td style='border: 1px solid #cacaca; padding:3px'><button id='"+row_sen[i][1].substring(1,row_sen[i][1].length-1)+"'>Més informació</button></td>";  							
            msgDiv +="</tr>";  						
          }
          msgDiv +="</table>";
          msgDiv +="<hr>";    
          msgDiv +="<table style='width:100%'>";
          msgDiv +="<tr id='potSensors'><td style='width:50%; background-color: #cacaca'>Potencia necessaria: 0 w</td><td>Planells solars: 0</td></tr>";
          msgDiv +="<tr id='disSensors'><td style='width:50%; background-color: #cacaca'>Capacitat emmagatzematge necessari: 0Gb </td><td>Discos: 0</td></tr>";    				    				
          msgDiv +="</table>";    				

          $("#missatge").html(msgDiv);    		
        }
      }	

      function calPotencia(){
           potSensors =0;
           disSensors =0;			   		
           for (var s=1; s<row_sen.length; s++) {
             if ($("#sensor_"+s).prop("checked")){
               potSensors +=parseFloat(row_sen[s][3].substring(1,row_sen[s][3].length-1));
               disSensors +=parseFloat(row_sen[s][4].substring(1,row_sen[s][4].length-1));			   			
             }
           }			   		
           var nPanells=Math.round(Math.round(potSensors*10)/1000);ensors
           var nDiscs=Math.round(Math.round(disSensors*10)/1000);ensors
            $('#potSensors').html("<td>Potencia necessaria: "+potSensors+"</td><td>Panells soensorslars: "+nPanells+"</td>")
            $('#disSensors').html("<td>Capacitat emmagatzematge necessari: "+disSensors+"</tdensors><td>Discos: "+nDiscs+"</td>");
            folder4.__controllers[0].setValue(nPanells);				
            folder4.__controllers[1].setValue(nDiscs);				        		
      }	

      function botoInfoParametres() { 					
        $("#modalHeader").html("Elements orbitals");	
        $("#missatge").html('<object type="text/html" data="orbital.html" width="100%" height="450px"></object>');
        $("#finestraInfo").css({"visibility":"visible"});
        $("#finestraInfo").modal('show');
      }

      function addCategories() {
        categories=["NewSpace Catalunya", "Estacions espacials","Els més brillants","Meteorològics","Cerca i rescat","CubeSats","Seguiment de desastres","Geosíncrons","Localització (GPS)","Localització (Galileo)","Científics", "Educatius","Militars"];
        urls=["active","stations","visual","weather","sarsat","cubesat","dmc","geo","gps-ops","galileo","science", "education","military"];
        folder0.add(parametres, "tipus", categories).name('Tipus').onChange(canviaCategoria);
        folder0.add(parametres, "nomSats", nomSatelit).name('Nom').onChange( canviaSatelit );
        folder0.open();
      }

      function canviaCategoria() {
        enPausa = true;
        var numCategoria=-1;
        var i=0;
        do {
          if (parametres.tipus===categories[i]) {				
            numCategoria=i;
          }
          i++;
        }
        while(numCategoria<0);	
        $("select:eq(0)").css('width', '100%');			
        $("select:eq(1)").empty().append('<option value="">Carregant ...</option>').css('width', '100%');
        addTLE(numCategoria);
      }

      function addTLE(numCat) {		
        try {
          let carregant = document.getElementById("carregant");
          carregant.style.display = "unset";
          carregant.style.animationPlayState = "running";	
        } catch {
          console.log("Error: iniciant");
        }					
        
        if(numCat == 0) {  // Tipus "NewSpace Catalunya"
          fetch('downloadSingle.php?id=47961')  // Enxaneta
          .then(response => response.text())
          .then(response => 	{	
            var resposta = response.split('\r\n');
            cadenaSatelits = [];
            cadenaSatelits[1] = resposta[1];
            cadenaSatelits[2] = resposta[2];
            cadenaSatelits[3] = resposta[3];
            fetch('downloadTemp.php?id=70309')  // Menut
            .then(response => response.text())
            .then(response => 	{	
              var resposta = response.split('\r\n');
              cadenaSatelits[4] = resposta[0];
              cadenaSatelits[5] = resposta[1];
              cadenaSatelits[6] = resposta[2];
              nomSatelit = ['Enxaneta','Menut'];
              $("select:gt(0)").empty();
              for (i=0;i<nomSatelit.length;i++) {
                $("select:gt(0)").append('<option value="'+nomSatelit[i]+'">'+nomSatelit[i]+'</option>').css('width', '100%');											;
              }
              carregant.style.animationPlayState = "paused";
                    carregant.style.display = "none";										
            })
            .then(response => {
                canviaSatelit();
            })				    
            .catch(
              error => {
                console.error('Error propi:', error);
            });
          });
        } else {  // Altres tipus
          fetch('downloadLines.php?tipus='+ urls[numCat])
          .then(response => response.text())
          .then(response => 	{	nomSatelit = [];
            var resposta = response.split('\r\n');
            for (i=0;i<resposta.length/3-1;i++) {
              nomSatelit.push(resposta[3*i+1]);
            }
            nomSatelit.sort();
            cadenaSatelits = [];
            for (i=0;i<nomSatelit.length;i++) {
              for (j=0;j<resposta.length/3-1;j++) {
                if(resposta[3*j+1]===nomSatelit[i]) {
                  cadenaSatelits[3*i+1] = resposta[3*j+1];
                  cadenaSatelits[3*i+2] = resposta[3*j+2];
                  cadenaSatelits[3*i+3] = resposta[3*j+3];
                }
              }	
            }
            $("select:gt(0)").empty();
            for (i=0;i<nomSatelit.length;i++) {
              $("select:gt(0)").append('<option value="'+nomSatelit[i]+'">'+nomSatelit[i]+'</option>').css('width', '100%');											;
            }
            carregant.style.animationPlayState = "paused";
                  carregant.style.display = "none";										
          })
          .then(response => {
              canviaSatelit();
          })				    
          .catch(
            error => {
              console.error('Error propi:', error);
          });
        }	
      }

      function canviaSatelit() {
        mode = 'TLE';
        console.log('mode ' + mode);
        enPausa = true;
        estil.backgroundColor = 'green';
        botoIniciar.name("I N I C I A");
        numSat=0;
        for (i=0;i<nomSatelit.length;i++) {
          if(parametres.nomSats===nomSatelit[i]) {
            numSat=i;
          }				
        }
        var line1 = cadenaSatelits[3*(numSat)+2];
        var line2 = cadenaSatelits[3*(numSat)+3];

        console.log(cadenaSatelits[3*(numSat)+1]);
        console.log(line1);
        console.log(line2);

        var satrec = satellite.twoline2satrec(line1,line2);

        folder1.__controllers[1].setValue(satrec.nodeo*180/Math.PI);
        folder1.__controllers[2].setValue(satrec.inclo*180/Math.PI);
        folder1.__controllers[3].setValue(satrec.argpo*180/Math.PI);
        folder1.__controllers[4].setValue(Math.cbrt(MU/(satrec.no/60)**2)/1000);
        folder1.__controllers[5].setValue(satrec.ecco);
    
        var ara = new Date();
        var positionAndVelocity = satellite.propagate(satrec, ara);
        var gmst = satellite.gstime(ara);
        var position = satellite.eciToGeodetic(positionAndVelocity.position, gmst);
        var positionEci = positionAndVelocity.position;
        satTLEx = positionEci.x * 1000 / rTerra;
        satTLEy = positionEci.y * 1000 / rTerra;
        satTLEz = positionEci.z * 1000 / rTerra;
        var posGreenwich = [];
        posGreenwich.x = rTerra / 1000;
        posGreenwich.y = 0;
        posGreenwich.z = 0;
        var posEcf  = satellite.eciToEcf(posGreenwich, gmst);
        angleRotTerra = Math.atan2(posEcf.y,posEcf.x);
        if (angleRotTerra>0) {
          angleRotTerra=angleRotTerra - 2 * Math.PI;
        }
        console.log('angleTerra: ' + (-angleRotTerra * 180 / Math.PI));
        folder1.__controllers[8].setValue(-angleRotTerra * 180 / Math.PI);
        folder1.__controllers[6].setValue(angleEscombrat * 180 / Math.PI);
        canviaParametres();
        mode = 'manual';
        console.log('mode ' + mode);
      }	
 
      function meanAnomaly2true(M, e, tolerance, maximum_iteration) {
        var E = M + e * Math.sin(M);
        var iteration = 0;
        var deltaM = 100;
        while (iteration < maximum_iteration && Math.abs(deltaM) > tolerance) {
          deltaM = (M - (E - e * Math.sin(E)));
          E = E + deltaM / (1 - e * Math.cos(E));
          iteration++;
        }
        var f = Math.acos((Math.cos(E) - e) / (1 - e * Math.cos(E)));
          f = f * (Math.sign(Math.sin(f)) * Math.sign(Math.sin(E)));
        return f;
      }	

    </script>
    <div id="carregant"></div>
  </body>
</html>